"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/is-array"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var utils = _interopRequireWildcard(require("./utils"));

var _reqlib = require("reqlib");

var HTTP_STATUS_NOT_FOUND = 404,
    HTTP_STATUS_SUCCESS = 200;

var Core =
/*#__PURE__*/
function () {
  function Core(config, request) {
    (0, _classCallCheck2.default)(this, Core);
    this.config = config;
    this.paramExcludes = (0, _keys.default)(config).concat(['_create', '_id', '_index', '_indices', '_source', '_type', '_types']);
    this.request = request || new _reqlib.Request(config);
  } // http://www.elasticsearch.org/guide/reference/api/index_/
  // .add to ease backwards compatibility


  (0, _createClass2.default)(Core, [{
    key: "add",
    value: function add() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var doc = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof doc === 'function') {
        callback = doc;
        doc = options;
        options = {};
      } // handle scenarios where options are not provided


      if (!doc) {
        doc = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index', '_type']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      var index = utils.getIndexSyntax(options, this.config),
          type = utils.getTypeSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, type, options._id, options.create || options._create ? '_create' : '');

      if (options._id) {
        return this.request.put(options, doc, callback);
      } else {
        return this.request.post(options, doc, callback);
      }
    } // http://www.elasticsearch.org/guide/reference/api/bulk/
    // Note: Formats input queries as follows in POST data:
    //
    // { header : {} } \n
    // { data : {} } \n
    // { header : {} } \n
    // { data : {} } \n
    //

  }, {
    key: "bulk",
    value: function bulk() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var commands = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof commands === 'function') {
        callback = commands;
        commands = options;
        options = {};
      } // handle scenarios where options are not provided


      if (!commands) {
        commands = options;
        options = {};
      }

      if (!(0, _isArray.default)(commands)) {
        return utils.promiseRejectOrCallback(new Error('commands provided must be in array format'), callback);
      }

      var index = utils.getIndexSyntax(options, null),
          // specifically don't want default settings
      serializedCommands = '',
          type = utils.getTypeSyntax(options, null);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, index ? type : null, '_bulk');
      commands.forEach(function (command) {
        serializedCommands += (0, _stringify.default)(command) + '\n';
      });
      return this.request.post(options, serializedCommands, callback);
    } // convenience method for bulk that specifies index action
    // and automatically creates appropriate action/meta entries
    // for the documents passed

  }, {
    key: "bulkIndex",
    value: function bulkIndex() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var documents = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof documents === 'function') {
        callback = documents;
        documents = options;
        options = {};
      } // handle scenarios where options are not provided


      if (!documents) {
        documents = options;
        options = {};
      }

      if (!(0, _isArray.default)(documents)) {
        return utils.promiseRejectOrCallback(new Error('documents provided must be in array format'), callback);
      }

      var action = {},
          commands = [],
          index = utils.getIndexSyntax(options, this.config),
          type = utils.getTypeSyntax(options, this.config);
      documents.forEach(function (document) {
        action = {
          index: {
            _index: index,
            _type: type
          }
        }; // fix for issue #28, ability to handle _id property on document

        if (document.hasOwnProperty('_id')) {
          action.index._id = document._id;
          delete document._id;
        }

        commands.push(action);
        commands.push(document);
      });
      return this.bulk(options, commands, callback);
    } // http://www.elasticsearch.org/guide/reference/api/count/

  }, {
    key: "count",
    value: function count() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var query = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof query === 'function') {
        callback = query;
        query = options;
        options = {};
      }

      if (!callback && !query && typeof options === 'function') {
        callback = options;
        query = null;
        options = {};
      } // correct situation if count is called without a query


      if (query && !query.query) {
        options = query;
        query = null;
      } // look for scenarios where options are omitted


      if (!query && options.query) {
        query = options;
        options = {};
      }

      var index = utils.getIndexSyntax(options, this.config),
          type = utils.getTypeSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, index ? type : null, '_count');

      if (query) {
        return this.request.post(options, query, callback);
      } else {
        return this.request.get(options, callback);
      }
    } // http://www.elasticsearch.org/guide/reference/api/delete/

  }, {
    key: "delete",
    value: function _delete() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;

      if (!callback && typeof options === 'function') {
        callback = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      var index = utils.getIndexSyntax(options, this.config),
          type = utils.getTypeSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, type, options._id);
      return this.request.delete(options, callback);
    } // http://www.elasticsearch.org/guide/reference/api/delete-by-query/

  }, {
    key: "deleteByQuery",
    value: function deleteByQuery() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var query = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof query === 'function') {
        callback = query;
        query = options;
        options = {};
      } // handle scenarios where options are not provided


      if (!query) {
        query = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      var index = utils.getIndexSyntax(options, this.config),
          type = utils.getTypeSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, type, '_query');
      return this.request.delete(options, query, callback);
    } // http://www.elasticsearch.org/guide/reference/api/get/

  }, {
    key: "exists",
    value: function exists() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;

      if (!callback && typeof options === 'function') {
        callback = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      var index = utils.getIndexSyntax(options, this.config),
          statusCode,
          type = utils.getTypeSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, type, options._id);
      this.request.once('response', function (context) {
        return statusCode = context.state.statusCode;
      });
      return this.request.head(options, function (err, data) {
        if (err) {
          if (err.statusCode && err.statusCode === HTTP_STATUS_NOT_FOUND) {
            data = {
              exists: false,
              statusCode: err.statusCode
            };
            return utils.promiseResolveOrCallback(data, callback);
          }

          return utils.promiseRejectOrCallback(err, callback);
        } // must listen to event...


        data = {
          exists: statusCode === HTTP_STATUS_SUCCESS
        };
        return utils.promiseResolveOrCallback(data, callback);
      });
    } // http://www.elasticsearch.org/guide/reference/api/explain/

  }, {
    key: "explain",
    value: function explain() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var query = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof query === 'function') {
        callback = query;
        query = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index', '_type', '_id']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      var index = utils.getIndexSyntax(options, this.config),
          type = utils.getTypeSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, type, options._id, '_explain'); // documentation indicates GET method...
      // sending POST data via GET not typical, using POST instead

      return this.request.post(options, query, callback);
    } // http://www.elasticsearch.org/guide/reference/api/get/

  }, {
    key: "get",
    value: function get() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;

      if (!callback && typeof options === 'function') {
        callback = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index', '_type', '_id']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      if ((0, _isArray.default)(options._id)) {
        var docs = [];

        options._id.forEach(function (id) {
          docs.push({
            _id: id
          });
        });

        return this.multiGet(options, docs, callback);
      }

      var includeSource = options._source && options._source !== false,
          index = utils.getIndexSyntax(options, this.config),
          type = utils.getTypeSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, type, options._id, includeSource ? '_source' : null); // optionally add source filters if _source is not a boolean value

      if (includeSource && typeof options._source !== 'boolean') {
        options.query._source = options._source;
      }

      return this.request.get(options, callback);
    } // http://www.elasticsearch.org/guide/reference/api/index_/
    // .add to ease backwards compatibility

  }, {
    key: "index",
    value: function index() {
      return this.add.apply(this, arguments);
    } // http://www.elasticsearch.org/guide/reference/api/more-like-this/

  }, {
    key: "moreLikeThis",
    value: function moreLikeThis() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;

      if (!callback && typeof options === 'function') {
        callback = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index', '_type', '_id']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      var index = utils.getIndexSyntax(options, this.config),
          type = utils.getTypeSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, type, options._id, '_mlt');
      return this.request.get(options, callback);
    } // http://www.elasticsearch.org/guide/reference/api/multi-get/

  }, {
    key: "multiGet",
    value: function multiGet() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var docs = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof docs === 'function') {
        callback = docs;
        docs = options;
        options = {};
      }

      if (!callback && typeof options === 'function') {
        callback = options;
        docs = null;
        options = {};
      } // handle scenarios where options are not provided


      if (!docs && (0, _isArray.default)(options)) {
        docs = options;
        options = {};
      }

      var missingIndex = false,
          missingType = false,
          self = this;
      docs.forEach(function (doc) {
        doc._index = doc._index || options._index || self.config._index || null;
        doc._type = doc._type || options._type || self.config._type || null;

        if (!doc._index || doc._index === null) {
          missingIndex = true;
          return;
        }

        if (!doc._type) {
          missingType = true;
          return;
        }
      });

      if (missingIndex) {
        return utils.promiseRejectOrCallback(new Error('at least 1 or more docs supplied is missing index'), callback);
      }

      if (missingType) {
        return utils.promiseRejectOrCallback(new Error('at least 1 or more docs supplied is missing type'), callback);
      }

      options.path = utils.pathAppend('_mget'); // documentation indicates GET method...
      // sending POST data via GET not typical, using POST instead

      return this.request.post(options, {
        docs: docs
      }, callback);
    } // http://www.elasticsearch.org/guide/reference/api/multi-search/
    // Note: Formats input queries as follows in POST data:
    //
    // { query : {} } \n
    // { query : {} } \n
    // { query : {} } \n
    //

  }, {
    key: "multiSearch",
    value: function multiSearch() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var queries = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof queries === 'function') {
        callback = queries;
        queries = options;
        options = {};
      } // handle scenarios where options are not provided


      if (!queries && (0, _isArray.default)(options)) {
        queries = options;
        options = {};
      }

      if (!(0, _isArray.default)(queries)) {
        return utils.promiseRejectOrCallback(new Error('queries provided must be in array format'), callback);
      }

      var index = utils.getIndexSyntax(options, null),
          // specifically want to exclude defaults
      serializedQueries = '',
          type = utils.getTypeSyntax(options, null);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, index ? type : null, '_msearch');
      queries.forEach(function (query) {
        serializedQueries += (0, _stringify.default)(query);
        serializedQueries += '\n';
      }); // documentation indicates GET method...
      // sending POST data via GET not typical, using POST instead

      return this.request.post(options, serializedQueries, callback);
    }
  }, {
    key: "query",
    value: function query() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _query = arguments.length > 1 ? arguments[1] : undefined;

      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof _query === 'function') {
        callback = _query;
        _query = options;
        options = {};
      } // handle scenarios where only the query is provided


      if (!_query) {
        _query = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      var index = utils.getIndexSyntax(options, this.config),
          type = utils.getTypeSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, type, '_search'); // documentation indicates GET method...
      // sending POST data via GET not typical, using POST instead

      return this.request.post(options, _query, callback);
    } // http://www.elasticsearch.org/guide/reference/api/search/
    // .query to ease backwards compatibility

  }, {
    key: "search",
    value: function search() {
      return this.query.apply(this, arguments);
    } // http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-request-scroll.html

  }, {
    key: "scroll",
    value: function scroll() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var scrollId = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof scrollId === 'function') {
        callback = scrollId;
        scrollId = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['scroll']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend('_search/scroll'); // re-map to payload expected by ES6

      if (typeof scrollId === 'string') {
        scrollId = {
          scroll: options.scroll,
          'scroll_id': scrollId
        };
      } // documentation indicates GET method...
      // sending POST data via GET not typical, using POST instead


      return this.request.post(options, scrollId, callback);
    } // http://www.elasticsearch.org/guide/reference/api/search/term-suggest/
    // fix for issue #29

  }, {
    key: "suggest",
    value: function suggest() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var query = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof query === 'function') {
        callback = query;
        query = options;
        options = {};
      } // check for scenarios where options are not provided


      if (!query && options.suggest) {
        query = options;
        options = {};
      }

      var index = utils.getIndexSyntax(options, this.config),
          type = utils.getTypeSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes); // NOTE: in 5.0 _suggest deprecated in favor of _search endpoint
      // https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html

      options.path = utils.pathAppend(index, type, '_search');
      return this.request.post(options, query, callback);
    } // http://www.elasticsearch.org/guide/reference/api/update/

  }, {
    key: "update",
    value: function update() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var doc = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof doc === 'function') {
        callback = doc;
        doc = options;
        options = {};
      } // attempt to account for missing options


      if (!doc && (options.script || options.doc)) {
        doc = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index', '_type', '_id']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      } // fix for #36 - script can be blank, but not missing


      if ((doc.script === null || typeof doc.script === 'undefined') && !doc.doc) {
        return utils.promiseRejectOrCallback(new Error('script or doc is required for update operation'), callback);
      }

      var index = utils.getIndexSyntax(options, this.config),
          type = utils.getTypeSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, type, options._id, '_update');
      return this.request.post(options, doc, callback);
    } // http://www.elasticsearch.org/guide/reference/api/validate/

  }, {
    key: "validate",
    value: function validate() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var query = arguments.length > 1 ? arguments[1] : undefined;
      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (!callback && typeof query === 'function') {
        callback = query;
        query = options;
        options = {};
      } // handle scenarios where options are not provided


      if (!query && options.query) {
        query = options;
        options = {};
      }

      var err = utils.optionsUndefined(options, this.config, ['_index']);

      if (err) {
        return utils.promiseRejectOrCallback(err, callback);
      }

      var index = utils.getIndexSyntax(options, this.config),
          type = utils.getTypeSyntax(options, this.config);
      options.query = utils.exclude(options, this.paramExcludes);
      options.path = utils.pathAppend(index, type, '_validate/query'); // documentation indicates GET method...
      // sending POST data via GET not typical, using POST instead

      return this.request.post(options, query, callback);
    }
  }]);
  return Core;
}();

module.exports = {
  Core: Core
};
//# sourceMappingURL=core.js.map
