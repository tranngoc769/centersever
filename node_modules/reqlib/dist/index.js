"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _setImmediate2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/set-immediate"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _parseInt2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/parse-int"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/typeof"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/is-array"));

var _events = _interopRequireDefault(require("events"));

var _http = _interopRequireDefault(require("http"));

var _https = _interopRequireDefault(require("https"));

var _querystring = _interopRequireDefault(require("querystring"));

var _url = _interopRequireDefault(require("url"));

var DEFAULTS = {
  BASE_TEN: 10,
  FAILOVER_ERROR_CODES: ['ECONNREFUSED', 'ECONNRESET', 'ENOTFOUND'],
  HTTP_ERROR_CODE_RETRY_THRESHHOLD: 500,
  HTTP_ERROR_CODE_THRESHHOLD: 400,
  MAX_REDIRECT_COUNT: 5,
  MAX_RETRY_COUNT: 3,
  TIMEOUT: 60000
},
    EVENTS = {
  error: 'error',
  redirect: 'redirect',
  request: 'request',
  response: 'response',
  retry: 'retry'
},
    HTTP_HEADERS = {
  CONNECTION: 'Connection',
  CONTENT_LENGTH: 'Content-Length',
  CONTENT_TYPE: 'Content-Type',
  LOCATION: 'Location'
},
    // reference: https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection
HTTP_STATUS_CODES = {
  NO_CONTENT: 204,
  PROXY_REQUIRED: 305,
  REDIRECT_CODE_PERM: 301,
  REDIRECT_CODE_TEMP: 302,
  REDIRECT_NEW_CODE_PERM: 308,
  REDIRECT_NEW_CODE_TEMP: 307
},
    RE_CHARSET = /\ charset\=(a-z\-0-9)*/i,
    RE_CONTENT_TYPE_JSON = /json/i,
    RE_CONTENT_TYPE_TEXT = /json|xml|yaml|html|text|jwt/i,
    RE_ENDS_WITH_S = /s$/i,
    RE_TLS_PROTOCOL = /^https\:?/i,
    RE_URL_PARAMETERS = /(\/\:([a-z0-9\_\-\~\.]*))*/gi,
    SUPPORTED_REQUEST_OPTIONS = ['agent', 'auth', 'family', 'headers', 'host', 'hostname', 'hosts', // custom
'hostnames', // custom
// 'keepAlive', // custom
// 'keepAliveMsecs', // custom
'localAddress', 'maxRedirectCount', // custom
'maxRetryCount', // custom
'method', 'path', 'pathname', 'port', 'protocol', // use to determine HTTPS or HTTP
'query', // custom
'rejectUnauthorized', 'socketPath', 'timeout'];

function coalesce() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return args.filter(function (value) {
    return !isEmpty(value);
  })[0];
}

function ensureOptions(value) {
  if (!isObject(value) && typeof value === 'string') {
    return _url.default.parse(value);
  }

  return value;
}

function headerExists(headers, name) {
  return !isEmpty(headers[name]) || !isEmpty(headers[name.toLowerCase()]);
}

function isEmpty(value) {
  return value === null || [typeof value === 'undefined', typeof value === 'string' && !value.length, (0, _isArray.default)(value) && !value.length, isObject(value) && !(0, _keys.default)(value).length].some(function (result) {
    return result;
  });
}

function isObject(value) {
  return ![value === null, typeof value === 'undefined', (0, _typeof2.default)(value) !== 'object', (0, _isArray.default)(value), value && value.toString && !/^\[object\sObject\]$/.test(value.toString())].some(function (result) {
    return result;
  });
}

function mergeOptions(request) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var result = {}; // ensure request options exist

  request = request || {};
  request.options = request.options || {};
  SUPPORTED_REQUEST_OPTIONS.forEach(function (option) {
    var value = coalesce(options[option], request.options[option]);

    if (!isEmpty(value)) {
      result[option] = value;
    }
  }); // TODO: apply keep-alive
  // apply redirect

  result.maxRedirectCount = coalesce(result.maxRedirectCount, DEFAULTS.MAX_REDIRECT_COUNT); // apply retry

  result.maxRetryCount = coalesce(result.maxRetryCount, DEFAULTS.MAX_RETRY_COUNT); // apply timeout

  result.timeout = coalesce(result.timeout, DEFAULTS.TIMEOUT); // validate the query

  if (!isEmpty(result.query)) {
    // format objects using square-bracket notation
    result.query = squareBracketNotation(result.query); // serialization adjustments for querystring

    (0, _keys.default)(result.query).forEach(function (param) {
      // ensure arrays in querystring are properly serialized...
      if ((0, _isArray.default)(result.query[param]) && result.query[param].length > 1) {
        result.query[param] = result.query[param].join(',');
        return;
      } // turn date objects into ISO strings


      if (result.query[param] instanceof Date) {
        result.query[param] = result.query[param].toISOString();
        return;
      }
    }); // ensure the path is properly set

    result.path = [result.path, _querystring.default.stringify(result.query)].join('?');
  }

  return result;
}

function parseUrlPattern(urlPattern) {
  var parts = _url.default.parse(urlPattern); // determine parameters within the URL (if applicable)


  parts.path.match(RE_URL_PARAMETERS) // .filter((match) => RE_URL_PARAMETERS.test(match))
  .forEach(function (match) {
    var parameters = match.split(RE_URL_PARAMETERS);

    if (!parameters.length) {
      return;
    } // ensure parameters exist on the response


    parts.parameters = parts.parameters || []; // iterate each match

    parameters.filter(function (parameter) {
      return !isEmpty(parameter);
    }).forEach(function (parameter) {
      // isolate the parameters from the URL
      if (!/^\//.test(parameter)) {
        parts.parameters.push({
          name: parameter,
          regEx: new RegExp(":".concat(parameter))
        });
      }
    });
  });
  return parts;
}

function squareBracketNotation(query) {
  if (isEmpty(query)) {
    return query;
  }

  var buldSerializedQueryParam = function buldSerializedQueryParam(document) {
    var serializedKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    return (0, _keys.default)(document).forEach(function (key) {
      if (isEmpty(document[key])) {
        return;
      }

      if (!isObject(document[key])) {
        resultQuery[serializedKey ? "".concat(serializedKey, "[").concat(key, "]") : key] = document[key];
        return;
      }

      return buldSerializedQueryParam(document[key], serializedKey ? "".concat(serializedKey, "[").concat(key, "]") : key);
    });
  },
      resultQuery = {}; // kick off the serialization


  buldSerializedQueryParam(query);
  return resultQuery;
}

var Request =
/*#__PURE__*/
function (_events$EventEmitter) {
  (0, _inherits2.default)(Request, _events$EventEmitter);

  function Request(options) {
    var _this;

    (0, _classCallCheck2.default)(this, Request);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Request).call(this));
    _this.options = options;
    return _this;
  }

  (0, _createClass2.default)(Request, [{
    key: "call",
    value: function call(options, data, callback) {
      var executeRequest,
          requestContentType,
          self = this,
          state = {};

      if (typeof data === 'function') {
        callback = data;
        data = '';
      }

      if (typeof options === 'function') {
        callback = options;
        data = '';
        options = {};
      } // ensure default values for state


      state.data = data || '';
      state.failover = {
        index: 0,
        values: []
      };
      state.redirects = state.redirects || [];
      state.tries = state.tries || 1; // ensure default values for all request options

      options = mergeOptions(this, options);
      options.headers = options.headers || {}; // check to see if content-type is specified

      requestContentType = coalesce(options.headers[HTTP_HEADERS.CONTENT_TYPE], options.headers[HTTP_HEADERS.CONTENT_TYPE.toLowerCase()]); // default the content type if not provided...

      if (!requestContentType) {
        // apply application/json header as default (this is opinionated)
        options.headers[HTTP_HEADERS.CONTENT_TYPE] = 'application/json';
        requestContentType = 'application/json';
      } // ensure serialization of data


      if (typeof state.data !== 'string' && !Buffer.isBuffer(state.data)) {
        if (RE_CONTENT_TYPE_JSON.test(requestContentType)) {
          state.data = (0, _stringify.default)(data);
        } else if (data && data.toString && typeof data.toString === 'function') {
          state.data = data.toString();
        } // TODO: handle when state.data might not be a string or Buffer

      } // apply content length header


      if (typeof state.data === 'string') {
        options.headers[HTTP_HEADERS.CONTENT_LENGTH] = options.headers[HTTP_HEADERS.CONTENT_LENGTH] || Buffer.byteLength(state.data);
      }

      if (Buffer.isBuffer(state.data)) {
        options.headers[HTTP_HEADERS.CONTENT_LENGTH] = options.headers[HTTP_HEADERS.CONTENT_LENGTH] || state.data.length;
      } // setup failover if applicable


      ['host', 'hostname', 'hostnames', 'hosts'].forEach(function (field) {
        var key = RE_ENDS_WITH_S.test(field) ? field.slice(0, -1) : field; // if the host or hostname field value is an Array
        // map the values into the state.failover

        if ((0, _isArray.default)(options[field])) {
          state.failover.values = state.failover.values.concat(options[field].map(function (value) {
            return {
              key: key,
              value: value
            };
          })); // clear the failover settings from the options as it will be overridden

          delete options[field];
        }
      }); // set the current default host/hostname if failover options are present

      if (state.failover.values.length) {
        options[state.failover.values[state.failover.index].key] = state.failover.values[state.failover.index].value;
      } // correct for port in the hostname field...


      if (!isEmpty(options.hostname)) {
        var portIndex = options.hostname.indexOf(':');

        if (portIndex > 0) {
          // set port, host and hostname correctly
          options.port = (0, _parseInt2.default)(coalesce(options.port, options.hostname.substr(portIndex + 1)), DEFAULTS.BASE_TEN);
          options.host = options.hostname;
          options.hostname = options.hostname.substr(0, portIndex);
        }
      } // apply keep-alive header when specified

      /*
      if (options.keepAlive && !headerExists(options.headers, HTTP_HEADERS.CONNECTION)) {
      	options.headers[HTTP_HEADERS.CONNECTION] = 'keep-alive';
      }
      //*/


      executeRequest = new _promise.default(function (resolve, reject) {
        var clientRequest = function clientRequest() {
          // emit request event
          self.emit(EVENTS.request, {
            options: options,
            state: state
          });
          var client = (RE_TLS_PROTOCOL.test(options.protocol) ? _https.default : _http.default).request(options, function (response) {
            var chunks = [],
                contentType = coalesce(response.headers[HTTP_HEADERS.CONTENT_TYPE], response.headers[HTTP_HEADERS.CONTENT_TYPE.toLowerCase()]),
                json = RE_CONTENT_TYPE_JSON.test(contentType),
                redirect = [HTTP_STATUS_CODES.REDIRECT_CODE_PERM, HTTP_STATUS_CODES.REDIRECT_CODE_TEMP, HTTP_STATUS_CODES.REDIRECT_NEW_CODE_PERM, HTTP_STATUS_CODES.REDIRECT_NEW_CODE_TEMP].some(function (code) {
              return code === response.statusCode;
            }); // track response headers and status

            state.headers = response.headers;
            state.statusCode = response.statusCode; // emit response event

            self.emit(EVENTS.response, {
              options: options,
              state: state
            }); // determine if a proxy server is required...

            if (state.statusCode === HTTP_STATUS_CODES.PROXY_REQUIRED) {
              var err = new Error('proxy required');
              err.options = options;
              err.state = state;
              return reject(err);
            } // determine if a redirect has been detected


            if (redirect) {
              if (!headerExists(state.headers, HTTP_HEADERS.LOCATION)) {
                var _err = new Error('redirect requested with no location');

                _err.options = options;
                _err.state = state;
                return reject(_err);
              }

              if (state.redirects.length >= options.maxRedirectCount) {
                var _err2 = new Error('maximum redirect limit exceeded');

                _err2.options = options;
                _err2.state = state;
                return reject(_err2);
              } // read location from headers


              var redirectUrl = _url.default.parse(coalesce(response.headers[HTTP_HEADERS.LOCATION], response.headers[HTTP_HEADERS.LOCATION.toLowerCase()])); // set protocol when missing (i.e. location begins with '//' instead of protocol)


              if (isEmpty(redirectUrl.protocol)) {
                var previousRequestProtocol = state.redirects.length ? state.redirects[state.redirects.length - 1].protocol : options.protocol;
                redirectUrl = _url.default.parse([previousRequestProtocol, redirectUrl.href].join(''));
              } // remap options for next request


              (0, _assign.default)(options, redirectUrl); // increment number of redirects (to avoid endless looping)

              state.redirects.push(redirectUrl); // emit redirect event

              self.emit(EVENTS.redirect, {
                options: options,
                state: state
              }); // re-request based on the redirect location

              return (0, _setImmediate2.default)(clientRequest);
            } // utilize content-type to understand if response should be a stream
            // assume missing content-type header indicates text value


            if (contentType && !RE_CONTENT_TYPE_TEXT.test(contentType)) {
              if (context.statusCode >= DEFAULTS.HTTP_ERROR_CODE_THRESHHOLD) {
                var _err3 = new Error('HTTP error received for streaming Content-Type');

                _err3.options = options;
                _err3.state = state;
                _err3.stream = response;
                return reject(_err3);
              }

              return resolve(response);
            } // handle the response encoding...


            if (!isEmpty(contentType)) {
              var contentParts = contentType.split(RE_CHARSET); // if a charset was specified, apply it

              if (contentParts.length > 1) {
                try {
                  response.setEncoding(contentParts[contentParts.length - 1]);
                } catch (ex) {// TODO: handle warning...
                }
              }
            }

            response.on('data', function (chunk) {
              return chunks.push(chunk);
            });
            response.on('end', function () {
              var body = chunks.join(''),
                  error = state.statusCode >= DEFAULTS.HTTP_ERROR_CODE_THRESHHOLD,
                  retry = state.statusCode >= DEFAULTS.HTTP_ERROR_CODE_RETRY_THRESHHOLD && state.tries <= options.maxRetryCount,
                  statusCode = response.statusCode;

              if (json && statusCode !== HTTP_STATUS_CODES.NO_CONTENT && body.length) {
                try {
                  body = JSON.parse(body);
                } catch (ex) {
                  var _err4 = new Error('unable to parse JSON from response');

                  _err4.body = body;
                  _err4.options = options;
                  _err4.state = state;
                  return reject(_err4);
                }
              } // retry request when an error above the threshhold is received


              if (retry) {
                // emit retry event
                self.emit(EVENTS.retry, {
                  body: body,
                  options: options,
                  state: state
                }); // increment try count

                state.tries += 1;
                return clientRequest();
              }

              if (error) {
                var _err5 = new Error('HTTP error received');

                _err5.body = body;
                _err5.options = options;
                _err5.state = state;
                _err5.statusCode = statusCode;
                return reject(_err5);
              }

              return resolve(body);
            });
          });
          client.on(EVENTS.error, function (err) {
            var failover = state.failover.values.length && err.code && DEFAULTS.FAILOVER_ERROR_CODES.indexOf(err.code) !== -1; // check for failover

            if (failover) {
              state.tries += 1;
              state.failover.index = state.failover.index === state.failover.values.length - 1 ? 0 : state.failover.index + 1;

              if (state.tries <= state.failover.values.length) {
                // remove host and hostname from options to prevent conflict with prior request
                delete options.hostname;
                delete options.host;
                options[state.failover.values[state.failover.index].key] = state.failover.values[state.failover.index].value;
                return (0, _setImmediate2.default)(clientRequest);
              }
            } // retry if below retry count threshhold


            if (state.tries <= options.maxRetryCount) {
              state.tries += 1;
              return (0, _setImmediate2.default)(clientRequest);
            }

            return reject(err);
          }); // apply request timeout

          if (options.timeout) {
            // convert timeout to a number if provided as a string
            if (typeof options.timeout === 'string') {
              options.timeout = (0, _parseInt2.default)(options.timeout, DEFAULTS.BASE_TEN);
            }

            client.setTimeout(options.timeout, client.abort);
          } // send data


          if (state.data && (typeof state.data === 'string' || Buffer.isBuffer(state.data))) {
            client.write(state.data);
          } // finish up the client stream and end to send


          client.end();
        };

        clientRequest();
      }); // return Promise for async/await or then/catch

      if (isEmpty(callback)) {
        return executeRequest;
      } // execute and return results in callback


      return executeRequest.then(function (result) {
        return callback(null, result);
      }).catch(callback);
    }
  }, {
    key: "getOptions",
    value: function getOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return mergeOptions(this, options);
    } // delete

  }, {
    key: "delete",
    value: function () {
      var _delete2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee() {
        var options,
            callback,
            _args = arguments;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
                callback = _args.length > 1 ? _args[1] : undefined;

                if (typeof options === 'function' && isEmpty(callback)) {
                  callback = options;
                  options = {};
                }

                options = ensureOptions(options);
                options.method = 'DELETE';
                _context.next = 7;
                return this.call(options, callback);

              case 7:
                return _context.abrupt("return", _context.sent);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _delete() {
        return _delete2.apply(this, arguments);
      }

      return _delete;
    }() // get

  }, {
    key: "get",
    value: function () {
      var _get = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2() {
        var options,
            callback,
            _args2 = arguments;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                callback = _args2.length > 1 ? _args2[1] : undefined;

                if (typeof options === 'function' && isEmpty(callback)) {
                  callback = options;
                  options = {};
                }

                options = ensureOptions(options);
                options.method = 'GET';
                _context2.next = 7;
                return this.call(options, callback);

              case 7:
                return _context2.abrupt("return", _context2.sent);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function get() {
        return _get.apply(this, arguments);
      }

      return get;
    }() // head

  }, {
    key: "head",
    value: function () {
      var _head = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3() {
        var options,
            callback,
            _args3 = arguments;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
                callback = _args3.length > 1 ? _args3[1] : undefined;

                if (typeof options === 'function' && isEmpty(callback)) {
                  callback = options;
                  options = {};
                }

                options = ensureOptions(options);
                options.method = 'HEAD';
                _context3.next = 7;
                return this.call(options, callback);

              case 7:
                return _context3.abrupt("return", _context3.sent);

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function head() {
        return _head.apply(this, arguments);
      }

      return head;
    }() // patch

  }, {
    key: "patch",
    value: function () {
      var _patch = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4() {
        var options,
            data,
            callback,
            _args4 = arguments;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
                data = _args4.length > 1 ? _args4[1] : undefined;
                callback = _args4.length > 2 ? _args4[2] : undefined;

                if (typeof data === 'function' && isEmpty(callback)) {
                  callback = data;
                  data = null;
                }

                if (typeof options === 'function' && isEmpty(callback)) {
                  callback = options;
                  options = {};
                }

                options = ensureOptions(options);
                options.method = 'PATCH';
                _context4.next = 9;
                return this.call(options, data, callback);

              case 9:
                return _context4.abrupt("return", _context4.sent);

              case 10:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function patch() {
        return _patch.apply(this, arguments);
      }

      return patch;
    }() // post

  }, {
    key: "post",
    value: function () {
      var _post = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee5() {
        var options,
            data,
            callback,
            _args5 = arguments;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                options = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};
                data = _args5.length > 1 ? _args5[1] : undefined;
                callback = _args5.length > 2 ? _args5[2] : undefined;

                if (typeof data === 'function' && isEmpty(callback)) {
                  callback = data;
                  data = null;
                }

                if (typeof options === 'function' && isEmpty(callback)) {
                  callback = options;
                  options = {};
                }

                options = ensureOptions(options);
                options.method = 'POST';
                _context5.next = 9;
                return this.call(options, data, callback);

              case 9:
                return _context5.abrupt("return", _context5.sent);

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function post() {
        return _post.apply(this, arguments);
      }

      return post;
    }() // put

  }, {
    key: "put",
    value: function () {
      var _put = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee6() {
        var options,
            data,
            callback,
            _args6 = arguments;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                options = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};
                data = _args6.length > 1 ? _args6[1] : undefined;
                callback = _args6.length > 2 ? _args6[2] : undefined;

                if (typeof data === 'function' && isEmpty(callback)) {
                  callback = data;
                  data = null;
                }

                if (typeof options === 'function' && isEmpty(callback)) {
                  callback = options;
                  options = {};
                }

                options = ensureOptions(options);
                options.method = 'PUT';
                _context6.next = 9;
                return this.call(options, data, callback);

              case 9:
                return _context6.abrupt("return", _context6.sent);

              case 10:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function put() {
        return _put.apply(this, arguments);
      }

      return put;
    }()
  }]);
  return Request;
}(_events.default.EventEmitter);

var Resource =
/*#__PURE__*/
function () {
  function Resource(urlPattern, options) {
    (0, _classCallCheck2.default)(this, Resource);

    if (isEmpty(urlPattern)) {
      throw new Error('urlPattern argument is required');
    }

    this.request = new Request(options);
    this.urlParts = parseUrlPattern(urlPattern);
  }

  (0, _createClass2.default)(Resource, [{
    key: "create",
    value: function () {
      var _create = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee7(data, callback) {
        var options;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                options = this.urlParts;
                _context7.next = 3;
                return this.request.post(options, data, callback);

              case 3:
                return _context7.abrupt("return", _context7.sent);

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function create(_x, _x2) {
        return _create.apply(this, arguments);
      }

      return create;
    }()
  }, {
    key: "delete",
    value: function () {
      var _delete3 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee8() {
        var _len2,
            args,
            _key2,
            callback,
            options,
            _args8 = arguments;

        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                for (_len2 = _args8.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = _args8[_key2];
                }

                callback = args && typeof args[args.length - 1] === 'function' ? args[args.length - 1] : callback, options = this.urlParts; // TODO: map values based on urlParts.parameters

                options.query = args;
                _context8.next = 5;
                return this.request.delete(options, callback);

              case 5:
                return _context8.abrupt("return", _context8.sent);

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _delete() {
        return _delete3.apply(this, arguments);
      }

      return _delete;
    }()
  }, {
    key: "retrieve",
    value: function () {
      var _retrieve = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee9() {
        var _len3,
            args,
            _key3,
            callback,
            options,
            _args9 = arguments;

        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                for (_len3 = _args9.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = _args9[_key3];
                }

                callback = args && typeof args[args.length - 1] === 'function' ? args[args.length - 1] : callback, options = this.urlParts; // TODO: map values based on urlParts.parameters

                options.query = args;
                _context9.next = 5;
                return this.request.get(options, callback);

              case 5:
                return _context9.abrupt("return", _context9.sent);

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function retrieve() {
        return _retrieve.apply(this, arguments);
      }

      return retrieve;
    }()
  }, {
    key: "update",
    value: function () {
      var _update = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee10(data, callback) {
        var options;
        return _regenerator.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                options = this.urlParts;
                _context10.next = 3;
                return this.request.put(options, data, callback);

              case 3:
                return _context10.abrupt("return", _context10.sent);

              case 4:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function update(_x3, _x4) {
        return _update.apply(this, arguments);
      }

      return update;
    }()
  }]);
  return Resource;
}();

module.exports = {
  Request: Request,
  Resource: Resource
};
//# sourceMappingURL=index.js.map
